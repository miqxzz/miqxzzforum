
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Engls/forum-project2/forum_service/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/Engls/forum-project2/forum_service/docs/docs.go (100.0%)</option>
				
				<option value="file2">github.com/Engls/forum-project2/forum_service/internal/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/Engls/forum-project2/forum_service/internal/controllers/chat/client.go (0.0%)</option>
				
				<option value="file4">github.com/Engls/forum-project2/forum_service/internal/controllers/chat/hub.go (2.9%)</option>
				
				<option value="file5">github.com/Engls/forum-project2/forum_service/internal/controllers/http/ChatHandler.go (89.5%)</option>
				
				<option value="file6">github.com/Engls/forum-project2/forum_service/internal/controllers/http/CommentHandler.go (93.9%)</option>
				
				<option value="file7">github.com/Engls/forum-project2/forum_service/internal/controllers/http/PostHandler.go (74.4%)</option>
				
				<option value="file8">github.com/Engls/forum-project2/forum_service/internal/repository/adapters/sqldbadapters.go (81.8%)</option>
				
				<option value="file9">github.com/Engls/forum-project2/forum_service/internal/repository/chatRepository.go (100.0%)</option>
				
				<option value="file10">github.com/Engls/forum-project2/forum_service/internal/repository/commentsRepository.go (85.2%)</option>
				
				<option value="file11">github.com/Engls/forum-project2/forum_service/internal/repository/postRepository.go (92.2%)</option>
				
				<option value="file12">github.com/Engls/forum-project2/forum_service/internal/usecase/ChatUsecase.go (100.0%)</option>
				
				<option value="file13">github.com/Engls/forum-project2/forum_service/internal/usecase/CommentsUsecases.go (100.0%)</option>
				
				<option value="file14">github.com/Engls/forum-project2/forum_service/internal/usecase/PostUsecases.go (100.0%)</option>
				
				<option value="file15">github.com/Engls/forum-project2/forum_service/mocks/ChatRepository.go (60.7%)</option>
				
				<option value="file16">github.com/Engls/forum-project2/forum_service/mocks/ChatUsecase.go (0.0%)</option>
				
				<option value="file17">github.com/Engls/forum-project2/forum_service/mocks/CommentsRepository.go (61.8%)</option>
				
				<option value="file18">github.com/Engls/forum-project2/forum_service/mocks/CommentsUsecases.go (61.8%)</option>
				
				<option value="file19">github.com/Engls/forum-project2/forum_service/mocks/DB.go (21.2%)</option>
				
				<option value="file20">github.com/Engls/forum-project2/forum_service/mocks/PostRepository.go (69.0%)</option>
				
				<option value="file21">github.com/Engls/forum-project2/forum_service/mocks/PostUsecase.go (23.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        utils "github.com/Engls/EnglsJwt"
        _ "github.com/Engls/forum-project2/forum_service/docs"
        "github.com/Engls/forum-project2/forum_service/internal/config"
        "github.com/Engls/forum-project2/forum_service/internal/controllers/chat"
        "github.com/Engls/forum-project2/forum_service/internal/controllers/http"
        "github.com/Engls/forum-project2/forum_service/internal/repository"
        "github.com/Engls/forum-project2/forum_service/internal/usecase"
        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "github.com/jmoiron/sqlx"
        _ "github.com/mattn/go-sqlite3"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
        "go.uber.org/zap"
        "time"
)

// @title Forum Service API
// @version 1.0
// @description This is the API documentation for the Auth Service.
// @host localhost:8081
// @BasePath /
func main() <span class="cov0" title="0">{

        utils.InitLogger()
        logger := utils.GetLogger()

        cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to load config", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Info("Configuration loaded",
                zap.String("DB_PATH", cfg.DBPath),
                zap.String("PORT", cfg.Port),
                zap.String("JWT_SECRET", cfg.JWTSecret),
        )

        db, err := sqlx.Open("sqlite3", cfg.DBPath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to connect to database", zap.Error(err))
        }</span>
        <span class="cov0" title="0">defer db.Close()

        postRepo := repository.NewPostRepository(db, logger)
        commentRepo := repository.NewCommentsRepository(db, logger)
        chatRepo := repository.NewChatRepository(db, logger)
        postUsecase := usecase.NewPostUsecase(postRepo, logger)
        commentUsecase := usecase.NewCommentsUsecases(commentRepo, logger)
        hub := chat.NewHub()
        chatUsecase := usecase.NewChatUsecase(chatRepo, logger)
        jwtUtil := utils.NewJWTUtil(cfg.JWTSecret)

        postHandler := http.NewPostHandler(postUsecase, postRepo, jwtUtil, logger)
        commentHandler := http.NewCommentHandler(commentUsecase, jwtUtil, logger)
        chatHandler := http.NewChatHandler(hub, chatUsecase, jwtUtil, logger)

        go hub.Run()

        router := gin.Default()
        router.Use(cors.New(cors.Config{
                AllowOrigins:     []string{"http://localhost:3000"},
                AllowMethods:     []string{"PUT", "PATCH", "POST", "GET", "DELETE"},
                AllowHeaders:     []string{"Content-type", "Origin", "Authorization"},
                ExposeHeaders:    []string{"Content-Length"},
                AllowCredentials: true,
                MaxAge:           12 * time.Hour,
        }))

        router.GET("/ws", chatHandler.ServeWS)
        router.POST("/posts", postHandler.CreatePost)
        router.GET("/posts", postHandler.GetPosts)
        router.DELETE("/posts/:id", postHandler.DeletePost)
        router.POST("/posts/:id/comments", commentHandler.CreateComment)
        router.GET("/posts/:id/comments", commentHandler.GetCommentsByPostID)

        router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        if err := router.Run(cfg.Port); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to start server", zap.Error(err))
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/posts": {
            "get": {
                "description": "Возвращает список всех постов в системе",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Посты"
                ],
                "summary": "Получить все посты",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/entity.Post"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Создает новый пост в системе",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Посты"
                ],
                "summary": "Создать новый пост",
                "parameters": [
                    {
                        "description": "Данные поста",
                        "name": "post",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/entity.Post"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/entity.Post"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/posts/{id}": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Удаляет пост по ID (доступно автору или администратору)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Посты"
                ],
                "summary": "Удалить пост",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID поста",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/posts/{id}/comments": {
            "get": {
                "description": "Возвращает все комментарии для указанного поста",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Комментарии"
                ],
                "summary": "Получить комментарии поста",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID поста",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/entity.Comment"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Создает новый комментарий к указанному посту",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Комментарии"
                ],
                "summary": "Создать новый комментарий",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID поста",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Данные комментария",
                        "name": "comment",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/entity.Comment"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/entity.Comment"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/ws/chat": {
            "get": {
                "description": "Обновляет HTTP соединение до WebSocket для обмена сообщениями в реальном времени",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Чат"
                ],
                "summary": "Установить WebSocket соединение для чата",
                "parameters": [
                    {
                        "type": "string",
                        "description": "JWT токен авторизации",
                        "name": "token",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "ID пользователя",
                        "name": "userID",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Имя пользователя",
                        "name": "username",
                        "in": "query"
                    },
                    {
                        "type": "boolean",
                        "description": "Флаг аутентификации",
                        "name": "auth",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "101": {
                        "description": "Switching Protocols"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/entity.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "entity.Comment": {
            "type": "object",
            "properties": {
                "author_id": {
                    "type": "integer"
                },
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "post_id": {
                    "type": "integer"
                }
            }
        },
        "entity.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string",
                    "example": "error message"
                }
            }
        },
        "entity.Post": {
            "type": "object",
            "properties": {
                "author_id": {
                    "type": "integer",
                    "example": 1
                },
                "content": {
                    "type": "string",
                    "example": "Текст"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "title": {
                    "type": "string",
                    "example": "Заголовк"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8081",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "Forum Service API",
        Description:      "This is the API documentation for the Auth Service.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "os"

        "github.com/joho/godotenv"
)

type Config struct {
        Port           string
        DBPath         string
        MigrationsPath string
        JWTSecret      string
}

func LoadConfig() (Config, error) <span class="cov0" title="0">{

        err := godotenv.Load()
        if err != nil </span>{<span class="cov0" title="0">

        }</span>

        <span class="cov0" title="0">cfg := Config{
                Port:           getEnv("AUTH_SERVICE_PORT", ":8081"),
                DBPath:         getEnv("DB_PATH", "../../db/forum.db"),
                MigrationsPath: getEnv("AUTH_SERVICE_MIGRATIONS_PATH", "C:\\forum-project\\forum-backend\\auth_service\\migrations"),
                JWTSecret:      getEnv("JWT_SECRET", "your-secret-key"),
        }
        return cfg, nil</span>
}

func getEnv(key string, defaultValue string) string <span class="cov0" title="0">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return value</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package chat

import (
        "context"
        "github.com/Engls/forum-project2/forum_service/internal/entity"
        "github.com/Engls/forum-project2/forum_service/internal/usecase"
        "github.com/goccy/go-json"
        "github.com/gorilla/websocket"
        "log"
        "time"
)

type Client struct {
        Hub             *Hub
        Conn            *websocket.Conn
        Send            chan []byte
        UserID          int
        Username        string
        IsAuthenticated bool
        ChatUC          usecase.ChatUsecase
}

func (c *Client) ReadPump() <span class="cov0" title="0">{
        log.Printf("[CLIENT %d] Starting read pump", c.UserID)
        defer func() </span><span class="cov0" title="0">{
                log.Printf("[CLIENT %d] Closing read pump", c.UserID)
                c.Hub.Unregister &lt;- c
                c.Conn.Close()
        }</span>()

        <span class="cov0" title="0">c.Conn.SetReadLimit(512)
        c.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        c.Conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                c.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
                return nil
        }</span>)

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, rawMessage, err := c.Conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("[CLIENT %d] Read error: %v", c.UserID, err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">log.Printf("[CLIENT %d] Received raw message: %s", c.UserID, string(rawMessage))

                if err2 := c.handleIncomingMessage(rawMessage); err2 != nil </span><span class="cov0" title="0">{
                        log.Printf("[CLIENT %d] Message handling error: %v", c.UserID, err2)
                }</span>
        }
}

func (c *Client) handleIncomingMessage(rawMessage []byte) error <span class="cov0" title="0">{
        if len(rawMessage) == 0 </span><span class="cov0" title="0">{
                log.Printf("[CLIENT %d] Empty message received", c.UserID)
                return nil
        }</span>

        <span class="cov0" title="0">var msg entity.ChatMessage
        if err := json.Unmarshal(rawMessage, &amp;msg); err != nil </span><span class="cov0" title="0">{
                log.Printf("[CLIENT %d] Failed to unmarshal message, creating default: %v", c.UserID, err)
                msg = entity.ChatMessage{
                        UserID:    c.UserID,
                        Username:  c.Username,
                        Content:   string(rawMessage),
                        Timestamp: time.Now(),
                }
        }</span>

        <span class="cov0" title="0">if msg.Content == "" </span><span class="cov0" title="0">{
                log.Printf("[CLIENT %d] Empty content in message", c.UserID)
                return nil
        }</span>
        <span class="cov0" title="0">log.Println(c.IsAuthenticated)
        if c.IsAuthenticated </span><span class="cov0" title="0">{
                log.Printf("[CLIENT %d] Saving message to DB: %s", c.UserID, msg.Content)
                if err := c.ChatUC.HandleMessage(context.Background(), msg.UserID, msg.Username, msg.Content); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[CLIENT %d] DB save error: %v", c.UserID, err)
                }</span>
        }

        <span class="cov0" title="0">outMsg := map[string]interface{}{
                "userID":    msg.UserID,
                "username":  msg.Username,
                "content":   msg.Content,
                "timestamp": time.Now().Format(time.RFC3339),
        }

        jsonMsg, err := json.Marshal(outMsg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[CLIENT %d] Marshal error: %v", c.UserID, err)
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("[CLIENT %d] Broadcasting message: %s", c.UserID, string(jsonMsg))
        c.Hub.Broadcast &lt;- jsonMsg
        return nil</span>
}

func (c *Client) WritePump() <span class="cov0" title="0">{
        log.Printf("[CLIENT %d] Starting write pump", c.UserID)
        ticker := time.NewTicker(50 * time.Second)
        defer func() </span><span class="cov0" title="0">{
                log.Printf("[CLIENT %d] Closing write pump", c.UserID)
                ticker.Stop()
                c.Conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.Send:<span class="cov0" title="0">
                        c.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if !ok </span><span class="cov0" title="0">{
                                log.Printf("[CLIENT %d] Send channel closed, sending close message", c.UserID)
                                c.Conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">log.Printf("[CLIENT %d] Preparing to write message: %s", c.UserID, string(message))
                        w, err := c.Conn.NextWriter(websocket.TextMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[CLIENT %d] NextWriter error: %v", c.UserID, err)
                                return
                        }</span>
                        <span class="cov0" title="0">if _, err := w.Write(message); err != nil </span><span class="cov0" title="0">{
                                log.Printf("[CLIENT %d] Write error: %v", c.UserID, err)
                                return
                        }</span>

                        <span class="cov0" title="0">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("[CLIENT %d] Writer close error: %v", c.UserID, err)
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("[CLIENT %d] Message successfully sent", c.UserID)</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if err := c.Conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                log.Printf("[CLIENT %d] Ping error: %v", c.UserID, err)
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("[CLIENT %d] Ping sent", c.UserID)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package chat

import (
        "context"
        "encoding/json"
        "log"
)

type Hub struct {
        Clients    map[*Client]bool
        Broadcast  chan []byte
        Register   chan *Client
        Unregister chan *Client
}

func NewHub() *Hub <span class="cov8" title="1">{
        return &amp;Hub{
                Clients:    make(map[*Client]bool),
                Broadcast:  make(chan []byte, 100), // Буферизованный канал
                Register:   make(chan *Client),
                Unregister: make(chan *Client),
        }
}</span>

func (h *Hub) Run() <span class="cov0" title="0">{
        log.Println("Hub started running")
        for </span><span class="cov0" title="0">{
                select </span>{
                case client := &lt;-h.Register:<span class="cov0" title="0">
                        log.Printf("[HUB] Registering new client: UserID=%d, Username=%s", client.UserID, client.Username)
                        h.Clients[client] = true

                        messages, err := client.ChatUC.GetRecentMessages(context.Background(), 50)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[HUB] Error getting messages: %v", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">log.Printf("[HUB] Sending %d historical messages to client %d", len(messages), client.UserID)

                        for _, msg := range messages </span><span class="cov0" title="0">{
                                jsonMsg, err := json.Marshal(msg)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("[HUB] Error marshaling message: %v", err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">select </span>{
                                case client.Send &lt;- jsonMsg:<span class="cov0" title="0">
                                        log.Printf("[HUB] Historical message sent to %d", client.UserID)</span>
                                default:<span class="cov0" title="0">
                                        log.Printf("[HUB] Client %d send channel blocked, closing", client.UserID)
                                        close(client.Send)
                                        delete(h.Clients, client)</span>
                                }
                        }

                case client := &lt;-h.Unregister:<span class="cov0" title="0">
                        log.Printf("[HUB] Unregistering client: UserID=%d", client.UserID)
                        if _, ok := h.Clients[client]; ok </span><span class="cov0" title="0">{
                                delete(h.Clients, client)
                                close(client.Send)
                        }</span>

                case message := &lt;-h.Broadcast:<span class="cov0" title="0">
                        log.Printf("[HUB] Broadcasting message to %d clients: %s", len(h.Clients), string(message))
                        if len(message) == 0 </span><span class="cov0" title="0">{
                                log.Println("[HUB] Warning: empty message received")
                                continue</span>
                        }

                        <span class="cov0" title="0">for client := range h.Clients </span><span class="cov0" title="0">{
                                select </span>{
                                case client.Send &lt;- message:<span class="cov0" title="0">
                                        log.Printf("[HUB] Message sent to client %d", client.UserID)</span>
                                default:<span class="cov0" title="0">
                                        log.Printf("[HUB] Client %d channel blocked, disconnecting", client.UserID)
                                        close(client.Send)
                                        delete(h.Clients, client)</span>
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package http

import (
        utils "github.com/Engls/EnglsJwt"
        "net/http"
        "strconv"

        "github.com/Engls/forum-project2/forum_service/internal/controllers/chat"
        "github.com/Engls/forum-project2/forum_service/internal/usecase"
        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
        "go.uber.org/zap"
)

var upgrader = websocket.Upgrader{
        CheckOrigin: func(r *http.Request) bool <span class="cov8" title="1">{
                return true
        }</span>,
}

type ChatHandler struct {
        hub     *chat.Hub
        chatUC  usecase.ChatUsecase
        jwtUtil *utils.JWTUtil
        logger  *zap.Logger
}

func NewChatHandler(hub *chat.Hub, chatUC usecase.ChatUsecase, jwtUtil *utils.JWTUtil, logger *zap.Logger) *ChatHandler <span class="cov8" title="1">{
        return &amp;ChatHandler{
                hub:     hub,
                chatUC:  chatUC,
                jwtUtil: jwtUtil,
                logger:  logger,
        }
}</span>

// ServeWS godoc
// @Summary Установить WebSocket соединение для чата
// @Description Обновляет HTTP соединение до WebSocket для обмена сообщениями в реальном времени
// @Tags Чат
// @Accept json
// @Produce json
// @Param token query string true "JWT токен авторизации"
// @Param userID query int true "ID пользователя"
// @Param username query string false "Имя пользователя"
// @Param auth query bool true "Флаг аутентификации"
// @Success 101 "Switching Protocols" {object} nil
// @Failure 400 {object} entity.ErrorResponse
// @Failure 401 {object} entity.ErrorResponse
// @Failure 500 {object} entity.ErrorResponse
// @Router /ws/chat [get]
func (h *ChatHandler) ServeWS(c *gin.Context) <span class="cov8" title="1">{
        conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("WebSocket upgrade error", zap.Error(err))
                return
        }</span>

        <span class="cov8" title="1">realUserID, err := h.jwtUtil.GetUserIDFromToken(c.Query("token"))
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error("Failed to get user ID from token", zap.Error(err))
        }</span>
        <span class="cov8" title="1">userID, err := strconv.Atoi(c.Query("userID"))
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error("Failed to convert user ID to integer", zap.Error(err))
        }</span>
        <span class="cov8" title="1">h.logger.Info("Real userID", zap.Int("realUserID", realUserID))
        username := c.Query("username")
        isAuthenticated := c.Query("auth") == "true"

        client := &amp;chat.Client{
                Hub:             h.hub,
                Conn:            conn,
                Send:            make(chan []byte, 256),
                UserID:          userID,
                Username:        username,
                IsAuthenticated: isAuthenticated,
                ChatUC:          h.chatUC,
        }

        h.hub.Register &lt;- client

        go client.WritePump()
        go client.ReadPump()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package http

import (
        utils "github.com/Engls/EnglsJwt"
        "github.com/Engls/forum-project2/forum_service/internal/entity"
        "github.com/Engls/forum-project2/forum_service/internal/usecase"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "net/http"
        "strconv"
        "strings"
)

type CommentHandler struct {
        commentUsecase usecase.CommentsUsecases
        jwtUtil        *utils.JWTUtil
        logger         *zap.Logger
}

func NewCommentHandler(commentUsecase usecase.CommentsUsecases, jwtUtil *utils.JWTUtil, logger *zap.Logger) *CommentHandler <span class="cov8" title="1">{
        return &amp;CommentHandler{commentUsecase: commentUsecase, jwtUtil: jwtUtil, logger: logger}
}</span>

// CreateComment godoc
// @Summary Создать новый комментарий
// @Description Создает новый комментарий к указанному посту
// @Tags Комментарии
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "ID поста"
// @Param comment body entity.Comment true "Данные комментария"
// @Success 201 {object} entity.Comment
// @Failure 400 {object} entity.ErrorResponse
// @Failure 401 {object} entity.ErrorResponse
// @Failure 500 {object} entity.ErrorResponse
// @Router /posts/{id}/comments [post]
func (h *CommentHandler) CreateComment(c *gin.Context) <span class="cov8" title="1">{
        postIDStr := c.Param("id")
        postID, err := strconv.Atoi(postIDStr)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error("Invalid post ID", zap.Error(err))
                c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "Invalid post ID"})
                return
        }</span>

        <span class="cov8" title="1">var comment entity.Comment
        if err := c.BindJSON(&amp;comment); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to bind JSON", zap.Error(err))
                c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov8" title="1">{
                h.logger.Error("Authorization header required")
                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
                return
        }</span>

        <span class="cov8" title="1">tokenString := strings.Replace(authHeader, "Bearer ", "", 1)
        if tokenString == authHeader </span><span class="cov8" title="1">{
                h.logger.Error("Invalid Authorization header format")
                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid Authorization header format"})
                return
        }</span>

        <span class="cov8" title="1">userID, err := h.jwtUtil.GetUserIDFromToken(tokenString)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error("Invalid token or user ID", zap.Error(err))
                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid token or user ID"})
                return
        }</span>

        <span class="cov8" title="1">comment.PostId = postID
        comment.AuthorId = userID

        createdComment, err := h.commentUsecase.CreateComment(c.Request.Context(), comment)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error("Failed to create comment", zap.Error(err))
                c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Info("Comment created successfully", zap.Int("postID", postID), zap.Int("userID", userID))
        c.JSON(http.StatusCreated, createdComment)</span>
}

// GetCommentsByPostID godoc
// @Summary Получить комментарии поста
// @Description Возвращает все комментарии для указанного поста
// @Tags Комментарии
// @Accept json
// @Produce json
// @Param id path int true "ID поста"
// @Success 200 {array} entity.Comment
// @Failure 400 {object} entity.ErrorResponse
// @Failure 500 {object} entity.ErrorResponse
// @Router /posts/{id}/comments [get]
func (h *CommentHandler) GetCommentsByPostID(c *gin.Context) <span class="cov8" title="1">{
        postIDStr := c.Param("id")
        postID, err := strconv.Atoi(postIDStr)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error("Invalid post ID", zap.Error(err))
                c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "Invalid post ID"})
                return
        }</span>

        <span class="cov8" title="1">comments, err := h.commentUsecase.GetCommentByPostID(c.Request.Context(), postID)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error("Failed to get comments", zap.Error(err))
                c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Info("Comments retrieved successfully", zap.Int("postID", postID))
        c.JSON(http.StatusOK, comments)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package http

import (
        utils "github.com/Engls/EnglsJwt"
        "github.com/Engls/forum-project2/forum_service/internal/entity"
        "github.com/Engls/forum-project2/forum_service/internal/repository"
        "github.com/Engls/forum-project2/forum_service/internal/usecase"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "net/http"
        "strconv"
        "strings"
)

type PostHandler struct {
        postUsecase usecase.PostUsecase
        postRepo    repository.PostRepository
        jwtUtil     *utils.JWTUtil
        logger      *zap.Logger
}

func NewPostHandler(
        postUsecase usecase.PostUsecase,
        postRepo repository.PostRepository,
        jwtUtil *utils.JWTUtil,
        logger *zap.Logger,
) *PostHandler <span class="cov8" title="1">{
        return &amp;PostHandler{
                postUsecase: postUsecase,
                postRepo:    postRepo,
                jwtUtil:     jwtUtil,
                logger:      logger,
        }
}</span>

// CreatePost godoc
// @Summary Создать новый пост
// @Description Создает новый пост в системе
// @Tags Посты
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param post body entity.Post true "Данные поста"
// @Success 201 {object} entity.Post
// @Failure 400 {object} entity.ErrorResponse
// @Failure 401 {object} entity.ErrorResponse
// @Failure 500 {object} entity.ErrorResponse
// @Router /posts [post]
func (h *PostHandler) CreatePost(c *gin.Context) <span class="cov8" title="1">{
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov8" title="1">{
                h.logger.Warn("Authorization header required")
                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
                return
        }</span>

        <span class="cov8" title="1">tokenString := strings.Replace(authHeader, "Bearer ", "", 1)
        if tokenString == authHeader </span><span class="cov8" title="1">{
                h.logger.Warn("Invalid Authorization header format", zap.String("header", authHeader))
                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid Authorization header format"})
                return
        }</span>

        <span class="cov8" title="1">userID, err := h.postRepo.GetUserIDByToken(c.Request.Context(), tokenString)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Warn("Invalid token", zap.Error(err))
                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
                return
        }</span>

        <span class="cov8" title="1">var post entity.Post
        if err := c.BindJSON(&amp;post); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to bind JSON", zap.Error(err))
                c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">post.AuthorId = userID

        h.logger.Info("Creating post", zap.Any("post", post))
        createdPost, err := h.postUsecase.CreatePost(c.Request.Context(), post)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error("Failed to create post", zap.Error(err))
                c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Info("Post created successfully", zap.Any("createdPost", createdPost))
        c.JSON(http.StatusCreated, createdPost)</span>
}

// GetPosts godoc
// @Summary Получить все посты
// @Description Возвращает список всех постов в системе
// @Tags Посты
// @Accept json
// @Produce json
// @Success 200 {array} entity.Post
// @Failure 500 {object} entity.ErrorResponse
// @Router /posts [get]
func (h *PostHandler) GetPosts(c *gin.Context) <span class="cov8" title="1">{
        h.logger.Info("Getting all posts")
        posts, err := h.postRepo.GetPosts(c.Request.Context())
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error("Failed to get posts", zap.Error(err))
                c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Info("Successfully retrieved posts", zap.Int("count", len(posts)))
        c.JSON(http.StatusOK, posts)</span>
}

// DeletePost godoc
// @Summary Удалить пост
// @Description Удаляет пост по ID (доступно автору или администратору)
// @Tags Посты
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "ID поста"
// @Success 204 "No Content"
// @Failure 400 {object} entity.ErrorResponse
// @Failure 401 {object} entity.ErrorResponse
// @Failure 403 {object} entity.ErrorResponse
// @Failure 404 {object} entity.ErrorResponse
// @Failure 500 {object} entity.ErrorResponse
// @Router /posts/{id} [delete]
func (h *PostHandler) DeletePost(c *gin.Context) <span class="cov8" title="1">{
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov8" title="1">{
                h.logger.Warn("Authorization header required")
                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
                return
        }</span>

        <span class="cov8" title="1">tokenString := strings.Replace(authHeader, "Bearer ", "", 1)
        if tokenString == authHeader </span><span class="cov8" title="1">{
                h.logger.Warn("Invalid Authorization header format", zap.String("header", authHeader))
                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid Authorization header format"})
                return
        }</span>

        <span class="cov8" title="1">postIDStr := c.Param("id")
        postID, err := strconv.Atoi(postIDStr)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid post ID", zap.String("postID", postIDStr), zap.Error(err))
                c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "Invalid post ID"})
                return
        }</span>

        <span class="cov8" title="1">userID, err := h.jwtUtil.GetUserIDFromToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid token or user ID", zap.Error(err))
                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid token or user ID"})
                return
        }</span>

        <span class="cov8" title="1">userRole, err := h.jwtUtil.GetRoleFromToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid token or user role", zap.Error(err))
                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid token or user role"})
                return
        }</span>

        <span class="cov8" title="1">if userRole != "admin" </span><span class="cov8" title="1">{
                post, err := h.postRepo.GetPostByID(c.Request.Context(), postID)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to get post", zap.Int("postID", postID), zap.Error(err))
                        c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": "Failed to get post"})
                        return
                }</span>

                <span class="cov8" title="1">if post.AuthorId != userID </span><span class="cov0" title="0">{
                        h.logger.Warn("Unauthorized attempt to delete post",
                                zap.Int("userID", userID),
                                zap.Int("postAuthorID", post.AuthorId),
                                zap.Int("postID", postID))
                        c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "You are not authorized to delete this post"})
                        return
                }</span>
        }

        <span class="cov8" title="1">h.logger.Info("Deleting post", zap.Int("postID", postID))
        err = h.postUsecase.DeletePost(c.Request.Context(), postID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to delete post", zap.Int("postID", postID), zap.Error(err))
                c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete post"})
                return
        }</span>

        <span class="cov8" title="1">h.logger.Info("Post deleted successfully", zap.Int("postID", postID))
        c.Status(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package adapters

import (
        "context"
        "database/sql"
        "github.com/jmoiron/sqlx"
)

type DbAdapter struct {
        *sql.DB
}

func (d *DbAdapter) Exec(query string, args ...any) (sql.Result, error) <span class="cov0" title="0">{
        return d.DB.Exec(query, args...)
}</span>

func (d *DbAdapter) Get(dest interface{}, query string, args ...interface{}) error <span class="cov0" title="0">{
        return d.DB.QueryRow(query, args...).Scan(dest)
}</span>

func (d *DbAdapter) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) <span class="cov8" title="1">{
        return d.DB.ExecContext(ctx, query, args...)
}</span>

func (d *DbAdapter) SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error <span class="cov8" title="1">{
        rows, err := d.DB.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        return sqlx.StructScan(rows, dest)</span>
}

func (d *DbAdapter) QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row <span class="cov8" title="1">{
        return d.DB.QueryRowContext(ctx, query, args...)
}</span>

func (d *DbAdapter) QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error) <span class="cov8" title="1">{
        return d.DB.QueryContext(ctx, query, args...)
}</span>

func (d *DbAdapter) GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error <span class="cov8" title="1">{
        return d.DB.QueryRowContext(ctx, query, args...).Scan(dest)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package repository

import (
        "context"
        "database/sql"
        "time"

        "github.com/Engls/forum-project2/forum_service/internal/entity"
        "go.uber.org/zap"
)

type DB interface {
        Exec(query string, args ...any) (sql.Result, error)
        Get(dest interface{}, query string, args ...interface{}) error
        ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
        SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
        QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
        QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
        GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
}

type ChatRepository interface {
        StoreMessage(ctx context.Context, msg entity.ChatMessage) error
        GetRecentMessages(ctx context.Context, limit int) ([]entity.ChatMessage, error)
}

type chatRepo struct {
        db     DB
        logger *zap.Logger
}

func NewChatRepository(db DB, logger *zap.Logger) ChatRepository <span class="cov8" title="1">{
        return &amp;chatRepo{db: db, logger: logger}
}</span>

func (r *chatRepo) StoreMessage(ctx context.Context, msg entity.ChatMessage) error <span class="cov8" title="1">{
        r.logger.Info("Saving message",
                zap.Int("userID", msg.UserID),
                zap.String("username", msg.Username),
                zap.String("content", msg.Content),
                zap.Time("timestamp", msg.Timestamp),
        )

        query := `INSERT INTO chat_messages (user_id, username, content, timestamp) VALUES (?, ?, ?, ?)`
        _, err := r.db.ExecContext(ctx, query, msg.UserID, msg.Username, msg.Content, msg.Timestamp.Format(time.RFC3339))
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Error("Failed to store message", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *chatRepo) GetRecentMessages(ctx context.Context, limit int) ([]entity.ChatMessage, error) <span class="cov8" title="1">{
        query := `
        SELECT id, user_id, username, content,
               timestamp
        FROM chat_messages
        ORDER BY timestamp DESC
        LIMIT ?`

        var messages []entity.ChatMessage
        err := r.db.SelectContext(ctx, &amp;messages, query, limit)
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Error("Failed to get recent messages", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">for i, j := 0, len(messages)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                messages[i], messages[j] = messages[j], messages[i]
        }</span>

        <span class="cov8" title="1">r.logger.Info("Recent messages retrieved successfully", zap.Int("count", len(messages)))
        return messages, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package repository

import (
        "context"
        "github.com/Engls/forum-project2/forum_service/internal/entity"
        "go.uber.org/zap"
)

type CommentsRepository interface {
        CreateComment(ctx context.Context, comment entity.Comment) (entity.Comment, error)
        GetCommentsByPostID(ctx context.Context, postID int) ([]entity.Comment, error)
}

type commentsRepository struct {
        db     DB
        logger *zap.Logger
}

func NewCommentsRepository(db DB, logger *zap.Logger) CommentsRepository <span class="cov8" title="1">{
        return &amp;commentsRepository{db: db, logger: logger}
}</span>

func (r *commentsRepository) CreateComment(ctx context.Context, comment entity.Comment) (entity.Comment, error) <span class="cov8" title="1">{
        query := `
                INSERT INTO comments (post_id, author_id, content)
                VALUES ($1, $2, $3)
                RETURNING id, created_at
        `
        err := r.db.QueryRowContext(ctx, query, comment.PostId, comment.AuthorId, comment.Content).Scan(&amp;comment.ID, &amp;comment.CreatedAt)
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Error("Failed to create comment", zap.Error(err), zap.Int("postID", comment.PostId), zap.Int("authorID", comment.AuthorId))
                return entity.Comment{}, err
        }</span>
        <span class="cov8" title="1">r.logger.Info("Comment created successfully", zap.Int("commentID", comment.ID), zap.Int("postID", comment.PostId), zap.Int("authorID", comment.AuthorId))
        return comment, nil</span>
}

func (r *commentsRepository) GetCommentsByPostID(ctx context.Context, postID int) ([]entity.Comment, error) <span class="cov8" title="1">{
        query := `
                SELECT id, post_id, author_id, content, created_at
                FROM comments
                WHERE post_id = $1
                ORDER BY created_at ASC
        `
        rows, err := r.db.QueryContext(ctx, query, postID)
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Error("Failed to get comments by post ID", zap.Error(err), zap.Int("postID", postID))
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var comments []entity.Comment
        for rows.Next() </span><span class="cov8" title="1">{
                var comment entity.Comment
                err := rows.Scan(&amp;comment.ID, &amp;comment.PostId, &amp;comment.AuthorId, &amp;comment.Content, &amp;comment.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to scan comment", zap.Error(err), zap.Int("postID", postID))
                        return nil, err
                }</span>
                <span class="cov8" title="1">comments = append(comments, comment)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error occurred while iterating over comments", zap.Error(err), zap.Int("postID", postID))
                return nil, err
        }</span>
        <span class="cov8" title="1">r.logger.Info("Comments retrieved successfully", zap.Int("postID", postID), zap.Int("count", len(comments)))
        return comments, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package repository

import (
        "context"
        "github.com/Engls/forum-project2/forum_service/internal/entity"
        "go.uber.org/zap"
)

type DBposts interface {
        Get(dest interface{}, query string, args ...interface{}) error
        SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
}

type PostRepository interface {
        CreatePost(ctx context.Context, post entity.Post) (*entity.Post, error)
        GetPosts(ctx context.Context) ([]entity.Post, error)
        GetPostByID(ctx context.Context, id int) (*entity.Post, error)
        UpdatePost(ctx context.Context, post entity.Post) (*entity.Post, error)
        DeletePost(ctx context.Context, id int) error
        GetUserIDByToken(ctx context.Context, token string) (int, error)
}

type postRepository struct {
        db     DB
        logger *zap.Logger
}

func NewPostRepository(db DB, logger *zap.Logger) PostRepository <span class="cov8" title="1">{
        return &amp;postRepository{db: db, logger: logger}
}</span>

func (r *postRepository) CreatePost(ctx context.Context, post entity.Post) (*entity.Post, error) <span class="cov8" title="1">{
        query := `INSERT INTO posts (author_id, title, content) VALUES (?, ?, ?)`
        result, err := r.db.ExecContext(ctx, query, post.AuthorId, post.Title, post.Content)
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Error("Failed to create post", zap.Error(err), zap.Int("authorID", post.AuthorId))
                return nil, err
        }</span>

        <span class="cov8" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get last insert ID", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">post.ID = int(id)
        r.logger.Info("Post created successfully", zap.Int("postID", post.ID), zap.Int("authorID", post.AuthorId))
        return &amp;post, nil</span>
}

func (r *postRepository) GetPosts(ctx context.Context) ([]entity.Post, error) <span class="cov8" title="1">{
        query := `SELECT id, author_id, title, content FROM posts`
        var posts []entity.Post
        err := r.db.SelectContext(ctx, &amp;posts, query)
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Error("Failed to get posts", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">r.logger.Info("Posts retrieved successfully", zap.Int("count", len(posts)))
        return posts, nil</span>
}

func (r *postRepository) GetPostByID(ctx context.Context, id int) (*entity.Post, error) <span class="cov8" title="1">{
        query := `SELECT id, author_id, title, content FROM posts WHERE id = ?`
        var post entity.Post
        err := r.db.GetContext(ctx, &amp;post, query, id)
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Error("Failed to get post by ID", zap.Error(err), zap.Int("postID", id))
                return nil, err
        }</span>
        <span class="cov0" title="0">r.logger.Info("Post retrieved successfully", zap.Int("postID", id))
        return &amp;post, nil</span>
}

func (r *postRepository) UpdatePost(ctx context.Context, post entity.Post) (*entity.Post, error) <span class="cov8" title="1">{
        query := `UPDATE posts SET title = ?, content = ? WHERE id = ?`
        _, err := r.db.ExecContext(ctx, query, post.Title, post.Content, post.ID)
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Error("Failed to update post", zap.Error(err), zap.Int("postID", post.ID))
                return nil, err
        }</span>
        <span class="cov8" title="1">r.logger.Info("Post updated successfully", zap.Int("postID", post.ID))
        return &amp;post, nil</span>
}

func (r *postRepository) DeletePost(ctx context.Context, id int) error <span class="cov8" title="1">{
        query := `DELETE FROM posts WHERE id = ?`
        _, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Error("Failed to delete post", zap.Error(err), zap.Int("postID", id))
                return err
        }</span>
        <span class="cov8" title="1">r.logger.Info("Post deleted successfully", zap.Int("postID", id))
        return nil</span>
}

func (r *postRepository) GetUserIDByToken(ctx context.Context, token string) (int, error) <span class="cov8" title="1">{
        query := `SELECT user_id FROM tokens WHERE token = ?`
        var userID int
        err := r.db.GetContext(ctx, &amp;userID, query, token)
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Error("Failed to get user ID by token", zap.Error(err), zap.String("token", token))
                return 0, err
        }</span>
        <span class="cov8" title="1">r.logger.Info("User ID retrieved successfully", zap.String("token", token), zap.Int("userID", userID))
        return userID, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package usecase

import (
        "context"
        "time"

        "github.com/Engls/forum-project2/forum_service/internal/entity"
        "github.com/Engls/forum-project2/forum_service/internal/repository"
        "go.uber.org/zap"
)

type ChatUsecase interface {
        HandleMessage(ctx context.Context, userID int, username, content string) error
        GetRecentMessages(ctx context.Context, limit int) ([]entity.ChatMessage, error)
}

type chatUsecase struct {
        repo   repository.ChatRepository
        logger *zap.Logger
}

func NewChatUsecase(repo repository.ChatRepository, logger *zap.Logger) ChatUsecase <span class="cov8" title="1">{
        return &amp;chatUsecase{repo: repo, logger: logger}
}</span>

func (uc *chatUsecase) HandleMessage(ctx context.Context, userID int, username, content string) error <span class="cov8" title="1">{
        message := entity.ChatMessage{
                UserID:    userID,
                Username:  username,
                Content:   content,
                Timestamp: time.Now(),
        }

        uc.logger.Info("Handling message",
                zap.Int("userID", userID),
                zap.String("username", username),
                zap.String("content", content),
        )

        err := uc.repo.StoreMessage(ctx, message)
        if err != nil </span><span class="cov8" title="1">{
                uc.logger.Error("Failed to store message", zap.Error(err))
                return err
        }</span>

        <span class="cov8" title="1">uc.logger.Info("Message stored successfully", zap.Int("userID", userID), zap.String("username", username))
        return nil</span>
}

func (uc *chatUsecase) GetRecentMessages(ctx context.Context, limit int) ([]entity.ChatMessage, error) <span class="cov8" title="1">{
        uc.logger.Info("Fetching recent messages", zap.Int("limit", limit))

        messages, err := uc.repo.GetRecentMessages(ctx, limit)
        if err != nil </span><span class="cov8" title="1">{
                uc.logger.Error("Failed to get recent messages", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">uc.logger.Info("Recent messages fetched successfully", zap.Int("count", len(messages)))
        return messages, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package usecase

import (
        "context"
        "github.com/Engls/forum-project2/forum_service/internal/entity"
        "github.com/Engls/forum-project2/forum_service/internal/repository"
        "go.uber.org/zap"
)

type CommentsUsecases interface {
        CreateComment(ctx context.Context, comment entity.Comment) (entity.Comment, error)
        GetCommentByPostID(ctx context.Context, postId int) ([]entity.Comment, error)
}

type commentsUsecases struct {
        commentRepo repository.CommentsRepository
        logger      *zap.Logger
}

func NewCommentsUsecases(commentRepo repository.CommentsRepository, logger *zap.Logger) CommentsUsecases <span class="cov8" title="1">{
        return &amp;commentsUsecases{commentRepo: commentRepo, logger: logger}
}</span>

func (u *commentsUsecases) CreateComment(ctx context.Context, comment entity.Comment) (entity.Comment, error) <span class="cov8" title="1">{
        u.logger.Info("Creating comment",
                zap.Int("postID", comment.PostId),
                zap.Int("authorID", comment.AuthorId),
                zap.String("content", comment.Content),
        )

        createdComment, err := u.commentRepo.CreateComment(ctx, comment)
        if err != nil </span><span class="cov8" title="1">{
                u.logger.Error("Failed to create comment", zap.Error(err))
                return entity.Comment{}, err
        }</span>

        <span class="cov8" title="1">u.logger.Info("Comment created successfully", zap.Int("commentID", createdComment.ID), zap.Int("postID", createdComment.PostId))
        return createdComment, nil</span>
}

func (u *commentsUsecases) GetCommentByPostID(ctx context.Context, postId int) ([]entity.Comment, error) <span class="cov8" title="1">{
        u.logger.Info("Fetching comments by post ID", zap.Int("postID", postId))

        comments, err := u.commentRepo.GetCommentsByPostID(ctx, postId)
        if err != nil </span><span class="cov8" title="1">{
                u.logger.Error("Failed to get comments by post ID", zap.Error(err), zap.Int("postID", postId))
                return nil, err
        }</span>

        <span class="cov8" title="1">u.logger.Info("Comments fetched successfully", zap.Int("postID", postId), zap.Int("count", len(comments)))
        return comments, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package usecase

import (
        "context"
        "github.com/Engls/forum-project2/forum_service/internal/entity"
        "github.com/Engls/forum-project2/forum_service/internal/repository"
        "go.uber.org/zap"
)

type PostUsecase interface {
        CreatePost(ctx context.Context, post entity.Post) (*entity.Post, error)
        GetPosts(ctx context.Context) ([]entity.Post, error)
        GetPostByID(ctx context.Context, id int) (*entity.Post, error)
        UpdatePost(ctx context.Context, post entity.Post) (*entity.Post, error)
        DeletePost(ctx context.Context, id int) error
}

type postUsecase struct {
        postRepo repository.PostRepository
        logger   *zap.Logger
}

func NewPostUsecase(postRepo repository.PostRepository, logger *zap.Logger) PostUsecase <span class="cov8" title="1">{
        return &amp;postUsecase{postRepo: postRepo, logger: logger}
}</span>

func (u *postUsecase) CreatePost(ctx context.Context, post entity.Post) (*entity.Post, error) <span class="cov8" title="1">{
        u.logger.Info("Creating post",
                zap.Int("authorID", post.AuthorId),
                zap.String("title", post.Title),
                zap.String("content", post.Content),
        )

        createdPost, err := u.postRepo.CreatePost(ctx, post)
        if err != nil </span><span class="cov8" title="1">{
                u.logger.Error("Failed to create post", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">u.logger.Info("Post created successfully", zap.Int("postID", createdPost.ID))
        return createdPost, nil</span>
}

func (u *postUsecase) GetPosts(ctx context.Context) ([]entity.Post, error) <span class="cov8" title="1">{
        u.logger.Info("Fetching all posts")

        posts, err := u.postRepo.GetPosts(ctx)
        if err != nil </span><span class="cov8" title="1">{
                u.logger.Error("Failed to get posts", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">u.logger.Info("Posts fetched successfully", zap.Int("count", len(posts)))
        return posts, nil</span>
}

func (u *postUsecase) GetPostByID(ctx context.Context, id int) (*entity.Post, error) <span class="cov8" title="1">{
        u.logger.Info("Fetching post by ID", zap.Int("postID", id))

        post, err := u.postRepo.GetPostByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                u.logger.Error("Failed to get post by ID", zap.Error(err), zap.Int("postID", id))
                return nil, err
        }</span>

        <span class="cov8" title="1">u.logger.Info("Post fetched successfully", zap.Int("postID", id))
        return post, nil</span>
}

func (u *postUsecase) UpdatePost(ctx context.Context, post entity.Post) (*entity.Post, error) <span class="cov8" title="1">{
        u.logger.Info("Updating post",
                zap.Int("postID", post.ID),
                zap.String("title", post.Title),
                zap.String("content", post.Content),
        )

        updatedPost, err := u.postRepo.UpdatePost(ctx, post)
        if err != nil </span><span class="cov8" title="1">{
                u.logger.Error("Failed to update post", zap.Error(err), zap.Int("postID", post.ID))
                return nil, err
        }</span>

        <span class="cov8" title="1">u.logger.Info("Post updated successfully", zap.Int("postID", post.ID))
        return updatedPost, nil</span>
}

func (u *postUsecase) DeletePost(ctx context.Context, id int) error <span class="cov8" title="1">{
        u.logger.Info("Deleting post", zap.Int("postID", id))

        err := u.postRepo.DeletePost(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                u.logger.Error("Failed to delete post", zap.Error(err), zap.Int("postID", id))
                return err
        }</span>

        <span class="cov8" title="1">u.logger.Info("Post deleted successfully", zap.Int("postID", id))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        context "context"

        entity "github.com/Engls/forum-project2/forum_service/internal/entity"
        mock "github.com/stretchr/testify/mock"
)

// ChatRepository is an autogenerated mock type for the ChatRepository type
type ChatRepository struct {
        mock.Mock
}

// GetRecentMessages provides a mock function with given fields: ctx, limit
func (_m *ChatRepository) GetRecentMessages(ctx context.Context, limit int) ([]entity.ChatMessage, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, limit)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetRecentMessages")</span>
        }

        <span class="cov8" title="1">var r0 []entity.ChatMessage
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) ([]entity.ChatMessage, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, limit)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, int) []entity.ChatMessage); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, limit)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]entity.ChatMessage)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, limit)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// StoreMessage provides a mock function with given fields: ctx, msg
func (_m *ChatRepository) StoreMessage(ctx context.Context, msg entity.ChatMessage) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, msg)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for StoreMessage")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, entity.ChatMessage) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, msg)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// NewChatRepository creates a new instance of ChatRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewChatRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *ChatRepository <span class="cov0" title="0">{
        mock := &amp;ChatRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        context "context"

        entity "github.com/Engls/forum-project2/forum_service/internal/entity"
        mock "github.com/stretchr/testify/mock"
)

// ChatUsecase is an autogenerated mock type for the ChatUsecase type
type ChatUsecase struct {
        mock.Mock
}

// GetRecentMessages provides a mock function with given fields: ctx, limit
func (_m *ChatUsecase) GetRecentMessages(ctx context.Context, limit int) ([]entity.ChatMessage, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, limit)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetRecentMessages")</span>
        }

        <span class="cov0" title="0">var r0 []entity.ChatMessage
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) ([]entity.ChatMessage, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, limit)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) []entity.ChatMessage); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, limit)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]entity.ChatMessage)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, limit)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// HandleMessage provides a mock function with given fields: ctx, userID, username, content
func (_m *ChatUsecase) HandleMessage(ctx context.Context, userID int, username string, content string) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, userID, username, content)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for HandleMessage")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int, string, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID, username, content)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewChatUsecase creates a new instance of ChatUsecase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewChatUsecase(t interface {
        mock.TestingT
        Cleanup(func())
}) *ChatUsecase <span class="cov0" title="0">{
        mock := &amp;ChatUsecase{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        context "context"

        entity "github.com/Engls/forum-project2/forum_service/internal/entity"
        mock "github.com/stretchr/testify/mock"
)

// CommentsRepository is an autogenerated mock type for the CommentsRepository type
type CommentsRepository struct {
        mock.Mock
}

// CreateComment provides a mock function with given fields: ctx, comment
func (_m *CommentsRepository) CreateComment(ctx context.Context, comment entity.Comment) (entity.Comment, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, comment)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateComment")</span>
        }

        <span class="cov8" title="1">var r0 entity.Comment
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, entity.Comment) (entity.Comment, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, comment)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, entity.Comment) entity.Comment); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, comment)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(entity.Comment)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, entity.Comment) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, comment)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetCommentsByPostID provides a mock function with given fields: ctx, postID
func (_m *CommentsRepository) GetCommentsByPostID(ctx context.Context, postID int) ([]entity.Comment, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, postID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetCommentsByPostID")</span>
        }

        <span class="cov8" title="1">var r0 []entity.Comment
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) ([]entity.Comment, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, postID)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, int) []entity.Comment); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, postID)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]entity.Comment)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, postID)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewCommentsRepository creates a new instance of CommentsRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCommentsRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *CommentsRepository <span class="cov0" title="0">{
        mock := &amp;CommentsRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        context "context"

        entity "github.com/Engls/forum-project2/forum_service/internal/entity"
        mock "github.com/stretchr/testify/mock"
)

// CommentsUsecases is an autogenerated mock type for the CommentsUsecases type
type CommentsUsecases struct {
        mock.Mock
}

// CreateComment provides a mock function with given fields: ctx, comment
func (_m *CommentsUsecases) CreateComment(ctx context.Context, comment entity.Comment) (entity.Comment, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, comment)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateComment")</span>
        }

        <span class="cov8" title="1">var r0 entity.Comment
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, entity.Comment) (entity.Comment, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, comment)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, entity.Comment) entity.Comment); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, comment)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(entity.Comment)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, entity.Comment) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, comment)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetCommentByPostID provides a mock function with given fields: ctx, postId
func (_m *CommentsUsecases) GetCommentByPostID(ctx context.Context, postId int) ([]entity.Comment, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, postId)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetCommentByPostID")</span>
        }

        <span class="cov8" title="1">var r0 []entity.Comment
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) ([]entity.Comment, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, postId)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, int) []entity.Comment); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, postId)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]entity.Comment)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, postId)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewCommentsUsecases creates a new instance of CommentsUsecases. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCommentsUsecases(t interface {
        mock.TestingT
        Cleanup(func())
}) *CommentsUsecases <span class="cov0" title="0">{
        mock := &amp;CommentsUsecases{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"

        sql "database/sql"
)

// DB is an autogenerated mock type for the DB type
type DB struct {
        mock.Mock
}

// Exec provides a mock function with given fields: query, args
func (_m *DB) Exec(query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Exec")</span>
        }

        <span class="cov0" title="0">var r0 sql.Result
        var r1 error
        if rf, ok := ret.Get(0).(func(string, ...interface{}) (sql.Result, error)); ok </span><span class="cov0" title="0">{
                return rf(query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, ...interface{}) sql.Result); ok </span><span class="cov0" title="0">{
                r0 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sql.Result)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// ExecContext provides a mock function with given fields: ctx, query, args
func (_m *DB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov8" title="1">{
        var _ca []interface{}
        _ca = append(_ca, ctx, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ExecContext")</span>
        }

        <span class="cov8" title="1">var r0 sql.Result
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (sql.Result, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, query, args...)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) sql.Result); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query, args...)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sql.Result)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, query, args...)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// Get provides a mock function with given fields: dest, query, args
func (_m *DB) Get(dest interface{}, query string, args ...interface{}) error <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, dest, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Get")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(interface{}, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r0 = rf(dest, query, args...)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// GetContext provides a mock function with given fields: ctx, dest, query, args
func (_m *DB) GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, dest, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetContext")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, interface{}, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, dest, query, args...)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// QueryContext provides a mock function with given fields: ctx, query, args
func (_m *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Rows
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (*sql.Rows, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *sql.Rows); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Rows)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// QueryRowContext provides a mock function with given fields: ctx, query, args
func (_m *DB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        var _ca []interface{}
        _ca = append(_ca, ctx, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryRowContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Row
        if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *sql.Row); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Row)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// SelectContext provides a mock function with given fields: ctx, dest, query, args
func (_m *DB) SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error <span class="cov8" title="1">{
        var _ca []interface{}
        _ca = append(_ca, ctx, dest, query)
        _ca = append(_ca, args...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SelectContext")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, interface{}, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, dest, query, args...)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// NewDB creates a new instance of DB. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDB(t interface {
        mock.TestingT
        Cleanup(func())
}) *DB <span class="cov0" title="0">{
        mock := &amp;DB{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        context "context"

        entity "github.com/Engls/forum-project2/forum_service/internal/entity"
        mock "github.com/stretchr/testify/mock"
)

// PostRepository is an autogenerated mock type for the PostRepository type
type PostRepository struct {
        mock.Mock
}

// CreatePost provides a mock function with given fields: ctx, post
func (_m *PostRepository) CreatePost(ctx context.Context, post entity.Post) (*entity.Post, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, post)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreatePost")</span>
        }

        <span class="cov8" title="1">var r0 *entity.Post
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, entity.Post) (*entity.Post, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, post)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, entity.Post) *entity.Post); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, post)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*entity.Post)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, entity.Post) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, post)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// DeletePost provides a mock function with given fields: ctx, id
func (_m *PostRepository) DeletePost(ctx context.Context, id int) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeletePost")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// GetPostByID provides a mock function with given fields: ctx, id
func (_m *PostRepository) GetPostByID(ctx context.Context, id int) (*entity.Post, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPostByID")</span>
        }

        <span class="cov8" title="1">var r0 *entity.Post
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) (*entity.Post, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, int) *entity.Post); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*entity.Post)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetPosts provides a mock function with given fields: ctx
func (_m *PostRepository) GetPosts(ctx context.Context) ([]entity.Post, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPosts")</span>
        }

        <span class="cov8" title="1">var r0 []entity.Post
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) ([]entity.Post, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context) []entity.Post); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]entity.Post)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetUserIDByToken provides a mock function with given fields: ctx, token
func (_m *PostRepository) GetUserIDByToken(ctx context.Context, token string) (int, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, token)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserIDByToken")</span>
        }

        <span class="cov8" title="1">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, token)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, token)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, token)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UpdatePost provides a mock function with given fields: ctx, post
func (_m *PostRepository) UpdatePost(ctx context.Context, post entity.Post) (*entity.Post, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, post)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdatePost")</span>
        }

        <span class="cov8" title="1">var r0 *entity.Post
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, entity.Post) (*entity.Post, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, post)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, entity.Post) *entity.Post); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, post)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*entity.Post)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, entity.Post) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, post)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewPostRepository creates a new instance of PostRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPostRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *PostRepository <span class="cov0" title="0">{
        mock := &amp;PostRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
        context "context"

        entity "github.com/Engls/forum-project2/forum_service/internal/entity"
        mock "github.com/stretchr/testify/mock"
)

// PostUsecase is an autogenerated mock type for the PostUsecase type
type PostUsecase struct {
        mock.Mock
}

// CreatePost provides a mock function with given fields: ctx, post
func (_m *PostUsecase) CreatePost(ctx context.Context, post entity.Post) (*entity.Post, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, post)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreatePost")</span>
        }

        <span class="cov8" title="1">var r0 *entity.Post
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, entity.Post) (*entity.Post, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, post)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, entity.Post) *entity.Post); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, post)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*entity.Post)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, entity.Post) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, post)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// DeletePost provides a mock function with given fields: ctx, id
func (_m *PostUsecase) DeletePost(ctx context.Context, id int) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeletePost")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// GetPostByID provides a mock function with given fields: ctx, id
func (_m *PostUsecase) GetPostByID(ctx context.Context, id int) (*entity.Post, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPostByID")</span>
        }

        <span class="cov0" title="0">var r0 *entity.Post
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) (*entity.Post, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) *entity.Post); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*entity.Post)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetPosts provides a mock function with given fields: ctx
func (_m *PostUsecase) GetPosts(ctx context.Context) ([]entity.Post, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPosts")</span>
        }

        <span class="cov0" title="0">var r0 []entity.Post
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) ([]entity.Post, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context) []entity.Post); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]entity.Post)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UpdatePost provides a mock function with given fields: ctx, post
func (_m *PostUsecase) UpdatePost(ctx context.Context, post entity.Post) (*entity.Post, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, post)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdatePost")</span>
        }

        <span class="cov0" title="0">var r0 *entity.Post
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, entity.Post) (*entity.Post, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, post)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, entity.Post) *entity.Post); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, post)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*entity.Post)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, entity.Post) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, post)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// NewPostUsecase creates a new instance of PostUsecase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPostUsecase(t interface {
        mock.TestingT
        Cleanup(func())
}) *PostUsecase <span class="cov0" title="0">{
        mock := &amp;PostUsecase{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
